# OpenCV for Unity memo
対応APIはJavaでラッパーされているAPIのみ
実行時に動的に読み込むデータファイルはStreamingAssets/いかに置いておく
下記に書いてある検出器は顔の物はAsset内に付属している。
OpenCV for Unity(OCU)で画像を扱う場合，OCU内にあるユーティリティクラスを使用してTexture2D->Matへの変換が必要になる。
ex)
`Utils.webCamTextureToMat(webcamtex,rgbMat,colors)`
画像解析を行う場合は色情報が必要ないのでグレースケールにしておく必要がある
ex)
```
Imgproc.cvtColor(rgbMat,grayMat,Imgproc.COLOR_RGB2GRAY);
//グレースケールへの変換
Imgproc.equalizeHist(grayMat,grayMat);
//ヒストグラムの平坦化をして画像解析に適した画像情報へ変換している。
```
入力画像，検出結果を格納するMatOfRectオブジェクト，スケールファクタ，オブジェクトを構成する近傍矩形の最小数，処理モード，最小ウィンドウサイズを引数に入れて顔を検出する
ex)
```cadence.detectMulticale(grayMat,faces,1.1,2,2,new Size(webCamTexture.height*0.2,ebCamTexture.height*0.2),new Size());```
検出された座標情報を元に赤い矩形を描写する。
ex)
```
OpenCVForUnity.CoreModule.Rect[] rects = faces.toArray ();
                for (int i = 0; i < rects.Length; i++) {
                    //Debug.Log ("detect faces " + rects [i]);
                    Imgproc.rectangle (rgbaMat, new Point (rects [i].x, rects [i].y), new Point (rects [i].x + rects [i].width, rects [i].y + rects [i].height), new Scalar (255, 0, 0, 255), 2);
                }
```
Mat形式をTexture2D形式へと変換して画面に表示する。
`Utils.fastMatToTexture2D (rgbaMat, texture);`
`gameObject.GetComponent<Renderer> ().material.mainTexture = texture;`

上記の処理をUpdateで繰り返すごとにinit()時にQuadのマテリアルに当てはめたテクスチャへ反映されるので画像が更新されていく。
# 物体検出
[参考スライド](https://www.slideshare.net/takmin/20141008-40019861)   
大量の学習画像から特徴を抽出し学習する。そのあと認識させたい画像から特徴を抽出し学習データと照らし合わせる。   
学習画像ー＞特徴量抽出:Haar-Like   
特徴量抽出->学習:Ada Boost
## AdaBoost
弱い識別器を並べて強い識別器を作成する機械学習アルゴリズム   
[アルゴリズム](https://ja.wikipedia.org/wiki/AdaBoost)   
例）●△□->🚙   
- 顔の学習の流れ   
1. 学習用の画像（顔を含む正解と含まない不正解）を用意する
2.  各々の画像ごとの重みを一様にする
3. 以下を繰り返す   
重みの合計が一になるように正規化   
各々の識別器に画像の判定を行わせて学習画像毎の重みをもとにエラー率を算出する  
エラー率が最も小さい識別器を選択する   
その識別器が間違った画像の重みを重くしていく。
4. 選択した識別器の重み付き和を最終的な強識別器にする。


## Haar-Like特徴
[詳細和訳](http://labs.eecs.tottori-u.ac.jp/sd/Member/oyamada/OpenCV/html/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html#face-detection)
1. Edge
2. Line
3. Center-surround

の三つ。特徴量とは白領域の画素数-黒領域の画素数。   
## 高速化
HaarLike特徴をAdaBoostアルゴリズムで使用することで高速化を望めるが，それ以上に高速化をするためにいくつかのグループに特徴を分けて１グループごとに画像を解析する。これをすることで1グループ目に人であることが検出されなかった場合そこの領域で検出を行う必要がなくなり必要最低限の領域の解析が可能となる。(Cascade-Classifer)
#### コラム
convolution->積和演算，二つの関数を重ね合わせた時の領域の和を足していく積分
カーネル->上の積の係数の3*3マトリックス
